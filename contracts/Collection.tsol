pragma ever-solidity >= 0.61.2;

pragma AbiHeader expire;
pragma AbiHeader time;
pragma AbiHeader pubkey;

import "./Nft.tsol";
import '@broxus/tip4/contracts/TIP4_1/TIP4_1Collection.tsol';
import '@broxus/tip4/contracts/TIP4_2/TIP4_2Collection.tsol';
import '@broxus/tip4/contracts/TIP4_3/TIP4_3Collection.tsol';

contract Collection is TIP4_2Collection, TIP4_3Collection {
	
    /**
    * Errors
    **/
    uint8 constant sender_is_not_owner = 101;
    uint8 constant value_is_less_than_required = 102;

    /// _remainOnNft - the number of crystals that will remain after the entire mint 
    /// process is completed on the Nft contract
    uint128 _remainOnNft = 0.3 ever;
    uint128 _lastTokenId;

    uint128 _mintingFee;

    address owner;

    mapping(address => bool) public hasMinted;

    constructor(
        TvmCell codeNft,
        string json,
        TvmCell codeIndex,
        TvmCell codeIndexBasis,
        address _owner,
        uint128 mintingFee
    )
		TIP4_1Collection(codeNft)
		TIP4_2Collection(json)
		TIP4_3Collection(codeIndex, codeIndexBasis) 		
    public {
        tvm.accept();
        _mintingFee = mintingFee;
        owner = _owner;
    }

	function mintNft(
        string json
    ) external virtual {
        require(msg.value > _remainOnNft + _mintingFee + (2 * _indexDeployValue), value_is_less_than_required);
        // require(!hasMinted[msg.sender], 101);
        
        // require(msg.value > _remainOnNft + 0.1 ever, value_is_less_than_required);
        tvm.rawReserve(_mintingFee, 4);

        if(hasMinted[msg.sender]){
            msg.sender.transfer(msg.value);
        }

        uint256 id = _lastTokenId;
        _totalSupply++;
        _lastTokenId++;

        TvmCell codeNft = _buildNftCode(address(this));
        TvmCell stateNft = _buildNftState(codeNft, id);
        
        hasMinted[msg.sender] = true;

        address nftAddr = new Nft{
            stateInit: stateNft,
            value: 0,
            flag: 128
        }(
            msg.sender,
            msg.sender,
            _remainOnNft,
            json,
            _codeIndex,
            _indexDeployValue,
            _indexDestroyValue
        );

        emit NftCreated(
            id, 
            nftAddr,
            msg.sender,
            msg.sender, 
            msg.sender
        );
    }

    function withdraw(address dest) external {
        tvm.accept();
        dest.transfer(address(this).balance - _remainOnNft, true);
    }

    function check_hasMinted(address user) public view returns (bool) {
        return hasMinted[user];
    }

    function get_balance() public view returns(uint){
        return address(this).balance;
    }

	 function _buildNftState(TvmCell code, uint256 id)
		internal
		pure
		virtual
		override (TIP4_2Collection, TIP4_3Collection)
		returns (TvmCell)
	{
		return tvm.buildStateInit({contr: Nft, varInit: {_id: id}, code: code});
	}
}